package csvtool

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"sort"
	"strings"
)

// NewReader returns a csv.Reader with the delimiter detected. As a second argument you
// can pass in a *Sniffer instance to use instead of the defaults, this can provide a different
// set of delimiters to look for.
func NewReader(r io.Reader, s ...*Sniffer) *csv.Reader {
	var sniffer *Sniffer
	if len(s) != 0 {
		sniffer = s[0]
	} else {
		sniffer = defaultSniffer()
	}
	return newReaderFromSniffer(r, sniffer)
}

func delimiter(r io.Reader, s *Sniffer) {

}

// NewSnifferReader returns a csv.Reader using a provided sniffer.
func newReaderFromSniffer(r io.Reader, s *Sniffer) *csv.Reader {
	b, _ := io.ReadAll(r)
	reader := bytes.NewReader(b)

	csvReader := csv.NewReader(reader)

	s.analyse(csvReader)

	reader.Seek(0, 0)

	output := csv.NewReader(reader)
	output.Comma = s.delimiter

	return output
}

// Describes a dialect of the CSV, and how likely it is the one.
type dialect struct {
	likelihood []float64
	delimiter  rune
}

type dialects []dialect

func (d dialects) String() string {
	out := ""
	for _, dia := range d {
		out += fmt.Sprintf("%#U: %v\n", dia.delimiter, dia.likelihood)
	}
	return out
}

func (d dialects) Len() int {
	return len(d)
}

func (d dialects) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d dialects) Less(i, j int) bool {
	if len(d[i].likelihood) == 0 {
		return false
	}
	if len(d[j].likelihood) == 0 {
		return true
	}
	return d[i].likelihood[0] > d[j].likelihood[0]
}

type frequencyMap map[rune]map[int]int

func (f frequencyMap) String() string {
	out := ""
	for r := range f {
		out += fmt.Sprintf("%#U: %v\n", r, f[r])
	}
	return out
}

// Sniffer works on the CSV file to detect its delimiter.
type Sniffer struct {
	frequencyMap frequencyMap
	sampleSize   int
	delimiter    rune
}

// DefaultSniffer returns the default Sniffer.
func defaultSniffer() *Sniffer {
	return NewSniffer(15, ',', '\t', ';', ':', '|')
}

// NewSniffer creates a new Sniffer struct. It can be provded with a sampleSize int which
// tells the sniffer how many rows to look at, and a list of rune delimiters.
func NewSniffer(sampleSize int, delims ...rune) *Sniffer {
	delimiterMap := frequencyMap{}

	for _, d := range delims {
		delimiterMap[d] = map[int]int{}
	}

	return &Sniffer{
		sampleSize:   sampleSize,
		delimiter:    ',',
		frequencyMap: delimiterMap,
	}
}

// Samples the first few lines, and tries to split on each delimiter. It counts the length of the split
// and how often it occurs. This is then used to guess the delimiter.
func (s *Sniffer) analyse(r *csv.Reader) rune {
	for i := 0; i < s.sampleSize; i++ {
		line, err := r.Read()
		if err != nil {
			break
		}
		if len(line) > 1 {
			s.increment(r.Comma, len(line))
			continue
		}

		for potential := range s.frequencyMap {
			split := strings.Split(strings.TrimSpace(line[0]), string(potential))
			s.increment(potential, len(split))
		}
	}

	return s.sniff()
}

// Create dialects by looking at the frequency map generated by analyse. Then sort them into the most
// likely one and return its delimiter.
func (s *Sniffer) sniff() rune {
	ds := dialects{}
	for potential := range s.frequencyMap {
		p := dialect{
			delimiter:  potential,
			likelihood: []float64{},
		}
		for split, occurences := range s.frequencyMap[potential] {
			p.likelihood = append(p.likelihood, float64(split)/float64(occurences))
		}
		if len(p.likelihood) != 0 {
			sort.Float64s(p.likelihood)
			ds = append(ds, p)
		}
	}
	sort.Sort(ds)
	if len(ds) == 0 {
		return ','
	}
	s.delimiter = ds[0].delimiter
	return s.delimiter
}

func (s *Sniffer) increment(r rune, amount int) {
	_, ok := s.frequencyMap[r][amount]
	if !ok {
		s.frequencyMap[r][amount] = 0
	}
	s.frequencyMap[r][amount]++
}
